# Milestone 1.5 - Authentication & Multi-User Support (Migration)

**Status:** PLANNED
**Priority:** High - Foundational feature
**Estimated Effort:** Large (8-12 hours implementation + testing)
**Dependencies:** None (can be implemented now)
**Branch:** `feature/authentication-multi-user`

## Overview

Migrate the application from single-user mode to multi-user mode with JWT-based authentication. This is an additive migration that preserves all existing functionality while adding user authentication and data isolation.

## Goals

- Enable multiple users to use the same deployment
- Secure user data with authentication
- Isolate data by user (each user sees only their own data)
- Preserve all existing data (associate with default user)
- Maintain backward compatibility with all existing features
- Implement industry-standard security practices

## Current State

### What We Have ‚úÖ
- Fully functional single-user application
- Complete database schema (7 models: Account, Transaction, Category, BankConnection, LinkedAccount, ExternalTransaction, SyncHistory)
- 40+ API endpoints across multiple features
- Complete frontend UI with Material-UI
- Docker-based deployment
- Prisma migrations infrastructure

### What We're Missing ‚ùå
- User model and authentication
- Login/registration system
- JWT token-based auth
- Data isolation (userId foreign keys)
- Protected routes (backend and frontend)
- User session management

### Why Migration (Not Rebuild)
- Preserves 5,000+ lines of working code
- Business logic remains unchanged
- Prisma migrations handle schema changes elegantly
- Adding columns and foreign keys is straightforward
- This was the planned architectural approach from day 1

## Migration Strategy

### Guiding Principles
1. **Additive, not destructive** - Add authentication without breaking existing features
2. **Data preservation** - All existing data associated with default user
3. **Incremental rollout** - Can be tested at each phase
4. **Backward compatible** - Existing features work identically after migration
5. **Security first** - Industry-standard JWT + bcrypt implementation

---

## Implementation Plan

### Phase 1: Database Schema Migration ‚öôÔ∏è

**Estimated Time:** 2 hours

#### 1.1 Create User Model

**File:** `backend/prisma/schema.prisma`

```prisma
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String   // bcrypt hashed (12 rounds)
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  accounts           Account[]
  transactions       Transaction[]
  categories         Category[]
  bankConnections    BankConnection[]

  @@map("users")
}
```

#### 1.2 Add userId Foreign Keys to Existing Models

**Models to Update:**
- `Account` - Add `userId String` + `user User @relation(...)`
- `Transaction` - Add `userId String` + `user User @relation(...)`
- `Category` - Add `userId String` + `user User @relation(...)` (nullable for system categories)
- `BankConnection` - Add `userId String` + `user User @relation(...)`

**Note:** LinkedAccount, ExternalTransaction, SyncHistory inherit userId through their parent relations

**Example for Account:**
```prisma
model Account {
  // ... existing fields ...

  userId    String
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}
```

#### 1.3 Create Migration

```bash
npx prisma migrate dev --name add_user_authentication
```

#### 1.4 Create Data Backfill Migration Script

**File:** `backend/prisma/migrations/YYYYMMDD_backfill_default_user.ts`

```typescript
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';

const prisma = new PrismaClient();

async function main() {
  // Create default user
  const defaultUser = await prisma.user.create({
    data: {
      email: 'admin@localhost',
      password: await bcrypt.hash('changeme123', 12),
      name: 'Default User',
    },
  });

  console.log(`Created default user: ${defaultUser.email}`);

  // Associate all existing data with default user
  const [accounts, transactions, categories, bankConnections] = await Promise.all([
    prisma.account.updateMany({
      data: { userId: defaultUser.id },
    }),
    prisma.transaction.updateMany({
      data: { userId: defaultUser.id },
    }),
    prisma.category.updateMany({
      data: { userId: defaultUser.id },
    }),
    prisma.bankConnection.updateMany({
      data: { userId: defaultUser.id },
    }),
  ]);

  console.log('Data backfill complete:');
  console.log(`  Accounts: ${accounts.count}`);
  console.log(`  Transactions: ${transactions.count}`);
  console.log(`  Categories: ${categories.count}`);
  console.log(`  Bank Connections: ${bankConnections.count}`);
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

**Run manually after migration:**
```bash
ts-node backend/prisma/migrations/YYYYMMDD_backfill_default_user.ts
```

#### Acceptance Criteria
- ‚úÖ User model created with email, password, name fields
- ‚úÖ All user-specific models have userId foreign key
- ‚úÖ Migration runs successfully
- ‚úÖ All existing data associated with default user
- ‚úÖ Database indexes added for userId fields
- ‚úÖ Cascade deletes configured properly

---

### Phase 2: Backend Authentication Infrastructure üîê

**Estimated Time:** 3-4 hours

#### 2.1 Install Dependencies

```bash
cd backend
npm install jsonwebtoken bcrypt
npm install --save-dev @types/jsonwebtoken @types/bcrypt
```

#### 2.2 Create Auth Types

**File:** `backend/src/types/auth.types.ts`

```typescript
export interface JWTPayload {
  userId: string;
  email: string;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
}

export interface RegisterRequest {
  email: string;
  password: string;
  name: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface RefreshTokenRequest {
  refreshToken: string;
}
```

#### 2.3 Create Auth Service

**File:** `backend/src/services/auth.service.ts`

```typescript
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { PrismaClient } from '@prisma/client';
import { JWTPayload, AuthTokens, RegisterRequest, LoginRequest } from '../types/auth.types';

const prisma = new PrismaClient();

const JWT_SECRET = process.env.JWT_SECRET!;
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET!;
const JWT_EXPIRES_IN = '15m'; // 15 minutes
const JWT_REFRESH_EXPIRES_IN = '7d'; // 7 days

export class AuthService {
  // Generate access and refresh tokens
  static generateTokens(userId: string, email: string): AuthTokens {
    const payload: JWTPayload = { userId, email };

    const accessToken = jwt.sign(payload, JWT_SECRET, {
      expiresIn: JWT_EXPIRES_IN,
    });

    const refreshToken = jwt.sign(payload, JWT_REFRESH_SECRET, {
      expiresIn: JWT_REFRESH_EXPIRES_IN,
    });

    return { accessToken, refreshToken };
  }

  // Verify access token
  static verifyAccessToken(token: string): JWTPayload {
    return jwt.verify(token, JWT_SECRET) as JWTPayload;
  }

  // Verify refresh token
  static verifyRefreshToken(token: string): JWTPayload {
    return jwt.verify(token, JWT_REFRESH_SECRET) as JWTPayload;
  }

  // Hash password
  static async hashPassword(password: string): Promise<string> {
    return bcrypt.hash(password, 12);
  }

  // Compare password
  static async comparePassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }

  // Register new user
  static async register(data: RegisterRequest): Promise<{ user: any; tokens: AuthTokens }> {
    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { email: data.email },
    });

    if (existingUser) {
      throw new Error('User already exists');
    }

    // Hash password
    const hashedPassword = await this.hashPassword(data.password);

    // Create user
    const user = await prisma.user.create({
      data: {
        email: data.email,
        password: hashedPassword,
        name: data.name,
      },
      select: {
        id: true,
        email: true,
        name: true,
        createdAt: true,
      },
    });

    // Generate tokens
    const tokens = this.generateTokens(user.id, user.email);

    return { user, tokens };
  }

  // Login user
  static async login(data: LoginRequest): Promise<{ user: any; tokens: AuthTokens }> {
    // Find user
    const user = await prisma.user.findUnique({
      where: { email: data.email },
    });

    if (!user) {
      throw new Error('Invalid credentials');
    }

    // Verify password
    const isValid = await this.comparePassword(data.password, user.password);

    if (!isValid) {
      throw new Error('Invalid credentials');
    }

    // Generate tokens
    const tokens = this.generateTokens(user.id, user.email);

    return {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        createdAt: user.createdAt,
      },
      tokens,
    };
  }

  // Refresh tokens
  static async refresh(refreshToken: string): Promise<AuthTokens> {
    try {
      const payload = this.verifyRefreshToken(refreshToken);

      // Verify user still exists
      const user = await prisma.user.findUnique({
        where: { id: payload.userId },
      });

      if (!user) {
        throw new Error('User not found');
      }

      // Generate new tokens
      return this.generateTokens(user.id, user.email);
    } catch (error) {
      throw new Error('Invalid refresh token');
    }
  }

  // Get user by ID
  static async getUserById(userId: string) {
    return prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        email: true,
        name: true,
        createdAt: true,
      },
    });
  }
}
```

#### 2.4 Create Auth Middleware

**File:** `backend/src/middlewares/auth.middleware.ts`

```typescript
import { Request, Response, NextFunction } from 'express';
import { AuthService } from '../services/auth.service';

// Extend Express Request type to include user
declare global {
  namespace Express {
    interface Request {
      user?: {
        userId: string;
        email: string;
      };
    }
  }
}

export const authenticate = async (req: Request, res: Response, next: NextFunction) => {
  try {
    // Get token from Authorization header
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({
        success: false,
        message: 'No token provided',
      });
    }

    const token = authHeader.substring(7); // Remove 'Bearer ' prefix

    // Verify token
    const payload = AuthService.verifyAccessToken(token);

    // Attach user to request
    req.user = {
      userId: payload.userId,
      email: payload.email,
    };

    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      message: 'Invalid or expired token',
    });
  }
};
```

#### 2.5 Create Auth Validation Schemas

**File:** `backend/src/validators/auth.validator.ts`

```typescript
import { z } from 'zod';

export const registerSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
    .regex(/[0-9]/, 'Password must contain at least one number'),
  name: z.string().min(2, 'Name must be at least 2 characters'),
});

export const loginSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(1, 'Password is required'),
});

export const refreshTokenSchema = z.object({
  refreshToken: z.string().min(1, 'Refresh token is required'),
});
```

#### 2.6 Create Auth Controller

**File:** `backend/src/controllers/auth.controller.ts`

```typescript
import { Request, Response, NextFunction } from 'express';
import { AuthService } from '../services/auth.service';
import { registerSchema, loginSchema, refreshTokenSchema } from '../validators/auth.validator';

export const register = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    // Validate input
    const validatedData = registerSchema.parse(req.body);

    // Register user
    const { user, tokens } = await AuthService.register(validatedData);

    res.status(201).json({
      success: true,
      data: {
        user,
        tokens,
      },
    });
  } catch (error: any) {
    if (error.name === 'ZodError') {
      res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: error.errors,
      });
    } else if (error.message === 'User already exists') {
      res.status(409).json({
        success: false,
        message: error.message,
      });
    } else {
      next(error);
    }
  }
};

export const login = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    // Validate input
    const validatedData = loginSchema.parse(req.body);

    // Login user
    const { user, tokens } = await AuthService.login(validatedData);

    res.status(200).json({
      success: true,
      data: {
        user,
        tokens,
      },
    });
  } catch (error: any) {
    if (error.name === 'ZodError') {
      res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: error.errors,
      });
    } else if (error.message === 'Invalid credentials') {
      res.status(401).json({
        success: false,
        message: error.message,
      });
    } else {
      next(error);
    }
  }
};

export const refresh = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    // Validate input
    const validatedData = refreshTokenSchema.parse(req.body);

    // Refresh tokens
    const tokens = await AuthService.refresh(validatedData.refreshToken);

    res.status(200).json({
      success: true,
      data: { tokens },
    });
  } catch (error: any) {
    if (error.name === 'ZodError') {
      res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: error.errors,
      });
    } else {
      res.status(401).json({
        success: false,
        message: 'Invalid refresh token',
      });
    }
  }
};

export const getProfile = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    const userId = req.user!.userId;

    const user = await AuthService.getUserById(userId);

    if (!user) {
      res.status(404).json({
        success: false,
        message: 'User not found',
      });
      return;
    }

    res.status(200).json({
      success: true,
      data: { user },
    });
  } catch (error) {
    next(error);
  }
};
```

#### 2.7 Create Auth Routes

**File:** `backend/src/routes/auth.routes.ts`

```typescript
import { Router } from 'express';
import { register, login, refresh, getProfile } from '../controllers/auth.controller';
import { authenticate } from '../middlewares/auth.middleware';

const router = Router();

// Public routes
router.post('/register', register);
router.post('/login', login);
router.post('/refresh', refresh);

// Protected routes
router.get('/profile', authenticate, getProfile);

export default router;
```

#### 2.8 Update app.ts to Register Auth Routes

**File:** `backend/src/app.ts`

```typescript
// Add import
import authRoutes from './routes/auth.routes';

// Register routes (before other routes)
app.use('/api/v1/auth', authRoutes);
```

#### 2.9 Update Environment Variables

**File:** `.env.example` and `.env`

```bash
# JWT Secrets (generate strong random strings)
JWT_SECRET=your-super-secret-jwt-key-min-32-chars
JWT_REFRESH_SECRET=your-super-secret-refresh-key-min-32-chars
```

Generate secrets:
```bash
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

#### Acceptance Criteria
- ‚úÖ Auth service with register, login, refresh, getUserById methods
- ‚úÖ Auth middleware extracts and verifies JWT tokens
- ‚úÖ Auth controller with validation
- ‚úÖ Auth routes registered in app
- ‚úÖ Password hashing with bcrypt (12 rounds)
- ‚úÖ JWT tokens with proper expiration (15m access, 7d refresh)
- ‚úÖ Strong password validation (min 8 chars, uppercase, lowercase, number)
- ‚úÖ Email validation
- ‚úÖ JWT secrets in environment variables

---

### Phase 3: Update Existing API Endpoints for User Isolation üîí

**Estimated Time:** 2-3 hours

#### 3.1 Strategy

For each existing endpoint, we need to:
1. Add `authenticate` middleware
2. Filter queries by `req.user.userId`
3. Prevent users from accessing other users' data

#### 3.2 Update Account Routes

**File:** `backend/src/routes/account.routes.ts`

```typescript
import { authenticate } from '../middlewares/auth.middleware';

// Add authenticate middleware to all routes
router.get('/', authenticate, getAccounts);
router.get('/:id', authenticate, getAccountById);
router.post('/', authenticate, createAccount);
router.put('/:id', authenticate, updateAccount);
router.delete('/:id', authenticate, deleteAccount);
// ... etc for all routes
```

#### 3.3 Update Account Service

**File:** `backend/src/services/account.service.ts`

**Before:**
```typescript
async getAccounts() {
  return prisma.account.findMany({
    include: { transactions: true }
  });
}
```

**After:**
```typescript
async getAccounts(userId: string) {
  return prisma.account.findMany({
    where: { userId },
    include: { transactions: true }
  });
}
```

Apply this pattern to ALL methods:
- `getAccounts(userId)` - Filter by userId
- `getAccountById(accountId, userId)` - Filter by accountId AND userId
- `createAccount(data, userId)` - Include userId in data
- `updateAccount(accountId, data, userId)` - Check ownership before update
- `deleteAccount(accountId, userId)` - Check ownership before delete

#### 3.4 Update Account Controller

**File:** `backend/src/controllers/account.controller.ts`

**Before:**
```typescript
export const getAccounts = async (req: Request, res: Response) => {
  const accounts = await AccountService.getAccounts();
  res.json({ success: true, data: accounts });
};
```

**After:**
```typescript
export const getAccounts = async (req: Request, res: Response) => {
  const userId = req.user!.userId;
  const accounts = await AccountService.getAccounts(userId);
  res.json({ success: true, data: accounts });
};
```

#### 3.5 Apply Same Pattern to All Services

**Services to Update:**
- ‚úÖ `account.service.ts` - All methods add userId parameter
- ‚úÖ `transaction.service.ts` - All methods add userId parameter
- ‚úÖ `category.service.ts` - Filter user categories (system categories visible to all)
- ‚úÖ `sync.service.ts` - All bank sync operations filtered by userId
- ‚úÖ `TransactionMappingService.ts` - Ensure mapped transactions include userId
- ‚úÖ `csv.service.ts` - Associate imported transactions with userId

**Controllers to Update:**
- ‚úÖ `account.controller.ts` - Extract userId from req.user
- ‚úÖ `transaction.controller.ts` - Extract userId from req.user
- ‚úÖ `category.controller.ts` - Extract userId from req.user
- ‚úÖ `sync.controller.ts` - Extract userId from req.user
- ‚úÖ `csv.controller.ts` - Extract userId from req.user

**Routes to Update:**
- ‚úÖ `account.routes.ts` - Add authenticate middleware
- ‚úÖ `transaction.routes.ts` - Add authenticate middleware
- ‚úÖ `category.routes.ts` - Add authenticate middleware
- ‚úÖ `sync.routes.ts` - Add authenticate middleware
- ‚úÖ `csv.routes.ts` - Add authenticate middleware

**Exception: Dev Routes**
- Keep `dev.routes.ts` unprotected (development only) OR
- Protect with environment check (only in development mode)

#### 3.6 Category Service Special Handling

Categories can be:
1. **System categories** - `userId = null` (visible to all users)
2. **User categories** - `userId = <user-id>` (visible only to owner)

```typescript
async getCategories(userId: string) {
  return prisma.category.findMany({
    where: {
      OR: [
        { userId: null },     // System categories
        { userId: userId }    // User categories
      ]
    },
    orderBy: { name: 'asc' }
  });
}
```

#### Acceptance Criteria
- ‚úÖ All routes protected with authenticate middleware
- ‚úÖ All service methods accept userId parameter
- ‚úÖ All queries filtered by userId
- ‚úÖ No user can access another user's data
- ‚úÖ System categories visible to all users
- ‚úÖ Proper error handling for unauthorized access (404, not 403 to avoid data leaks)

---

### Phase 4: Frontend Authentication Implementation üñ•Ô∏è

**Estimated Time:** 3-4 hours

#### 4.1 Install Dependencies

```bash
cd frontend
npm install jwt-decode
npm install --save-dev @types/jwt-decode
```

#### 4.2 Create Auth Types

**File:** `frontend/src/types/auth.types.ts`

```typescript
export interface User {
  id: string;
  email: string;
  name: string;
  createdAt: string;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
}

export interface AuthState {
  user: User | null;
  tokens: AuthTokens | null;
  isAuthenticated: boolean;
  isLoading: boolean;
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface RegisterData {
  email: string;
  password: string;
  name: string;
}
```

#### 4.3 Create Auth Service

**File:** `frontend/src/services/auth.service.ts`

```typescript
import apiClient from './api';
import { User, AuthTokens, LoginCredentials, RegisterData } from '../types/auth.types';

const TOKEN_KEY = 'auth_tokens';

export const authService = {
  // Store tokens in localStorage
  setTokens(tokens: AuthTokens): void {
    localStorage.setItem(TOKEN_KEY, JSON.stringify(tokens));
  },

  // Get tokens from localStorage
  getTokens(): AuthTokens | null {
    const tokens = localStorage.getItem(TOKEN_KEY);
    return tokens ? JSON.parse(tokens) : null;
  },

  // Clear tokens from localStorage
  clearTokens(): void {
    localStorage.removeItem(TOKEN_KEY);
  },

  // Register new user
  async register(data: RegisterData): Promise<{ user: User; tokens: AuthTokens }> {
    const response = await apiClient.post('/v1/auth/register', data);
    return response.data.data;
  },

  // Login user
  async login(credentials: LoginCredentials): Promise<{ user: User; tokens: AuthTokens }> {
    const response = await apiClient.post('/v1/auth/login', credentials);
    return response.data.data;
  },

  // Refresh access token
  async refresh(refreshToken: string): Promise<AuthTokens> {
    const response = await apiClient.post('/v1/auth/refresh', { refreshToken });
    return response.data.data.tokens;
  },

  // Get current user profile
  async getProfile(): Promise<User> {
    const response = await apiClient.get('/v1/auth/profile');
    return response.data.data.user;
  },
};
```

#### 4.4 Update API Client with Token Interceptor

**File:** `frontend/src/services/api.ts`

```typescript
import axios from 'axios';
import { authService } from './auth.service';

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3000/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor - Add token to requests
apiClient.interceptors.request.use(
  (config) => {
    const tokens = authService.getTokens();
    if (tokens?.accessToken) {
      config.headers.Authorization = `Bearer ${tokens.accessToken}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor - Handle token refresh
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // If 401 and we haven't tried to refresh yet
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const tokens = authService.getTokens();
        if (tokens?.refreshToken) {
          // Refresh the token
          const newTokens = await authService.refresh(tokens.refreshToken);
          authService.setTokens(newTokens);

          // Retry original request with new token
          originalRequest.headers.Authorization = `Bearer ${newTokens.accessToken}`;
          return apiClient(originalRequest);
        }
      } catch (refreshError) {
        // Refresh failed, clear tokens and redirect to login
        authService.clearTokens();
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

export default apiClient;
```

#### 4.5 Create Auth Context

**File:** `frontend/src/contexts/AuthContext.tsx`

```typescript
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { authService } from '../services/auth.service';
import { User, AuthTokens, LoginCredentials, RegisterData, AuthState } from '../types/auth.types';
import { jwtDecode } from 'jwt-decode';

interface AuthContextType extends AuthState {
  login: (credentials: LoginCredentials) => Promise<void>;
  register: (data: RegisterData) => Promise<void>;
  logout: () => void;
  refreshUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, setState] = useState<AuthState>({
    user: null,
    tokens: null,
    isAuthenticated: false,
    isLoading: true,
  });

  // Check if token is expired
  const isTokenExpired = (token: string): boolean => {
    try {
      const decoded: any = jwtDecode(token);
      return decoded.exp * 1000 < Date.now();
    } catch {
      return true;
    }
  };

  // Initialize auth state from localStorage
  useEffect(() => {
    const initAuth = async () => {
      const tokens = authService.getTokens();

      if (tokens?.accessToken && !isTokenExpired(tokens.accessToken)) {
        try {
          // Fetch user profile
          const user = await authService.getProfile();
          setState({
            user,
            tokens,
            isAuthenticated: true,
            isLoading: false,
          });
        } catch (error) {
          // Token invalid, clear and show login
          authService.clearTokens();
          setState({
            user: null,
            tokens: null,
            isAuthenticated: false,
            isLoading: false,
          });
        }
      } else {
        setState({
          user: null,
          tokens: null,
          isAuthenticated: false,
          isLoading: false,
        });
      }
    };

    initAuth();
  }, []);

  const login = useCallback(async (credentials: LoginCredentials) => {
    const { user, tokens } = await authService.login(credentials);
    authService.setTokens(tokens);
    setState({
      user,
      tokens,
      isAuthenticated: true,
      isLoading: false,
    });
  }, []);

  const register = useCallback(async (data: RegisterData) => {
    const { user, tokens } = await authService.register(data);
    authService.setTokens(tokens);
    setState({
      user,
      tokens,
      isAuthenticated: true,
      isLoading: false,
    });
  }, []);

  const logout = useCallback(() => {
    authService.clearTokens();
    setState({
      user: null,
      tokens: null,
      isAuthenticated: false,
      isLoading: false,
    });
  }, []);

  const refreshUser = useCallback(async () => {
    try {
      const user = await authService.getProfile();
      setState((prev) => ({ ...prev, user }));
    } catch (error) {
      console.error('Failed to refresh user:', error);
    }
  }, []);

  return (
    <AuthContext.Provider value={{ ...state, login, register, logout, refreshUser }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

#### 4.6 Create Protected Route Component

**File:** `frontend/src/components/auth/ProtectedRoute.tsx`

```typescript
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../../contexts/AuthContext';
import { LoadingSpinner } from '../common/LoadingSpinner';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    return <LoadingSpinner message="Loading..." />;
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
};
```

#### 4.7 Create Login Page

**File:** `frontend/src/pages/Login.tsx`

```typescript
import React, { useState } from 'react';
import {
  Box,
  Container,
  Paper,
  Typography,
  TextField,
  Button,
  Link,
  Alert,
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { LoginCredentials } from '../types/auth.types';

export const Login: React.FC = () => {
  const navigate = useNavigate();
  const { login } = useAuth();
  const [credentials, setCredentials] = useState<LoginCredentials>({
    email: '',
    password: '',
  });
  const [error, setError] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');
    setIsLoading(true);

    try {
      await login(credentials);
      navigate('/');
    } catch (err: any) {
      setError(err.response?.data?.message || 'Login failed. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container maxWidth="sm">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        <Paper elevation={3} sx={{ p: 4, width: '100%' }}>
          <Typography variant="h4" align="center" gutterBottom>
            Budget Tracker
          </Typography>
          <Typography variant="h6" align="center" color="text.secondary" sx={{ mb: 3 }}>
            Sign In
          </Typography>

          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}

          <form onSubmit={handleSubmit}>
            <TextField
              fullWidth
              label="Email"
              type="email"
              value={credentials.email}
              onChange={(e) => setCredentials({ ...credentials, email: e.target.value })}
              margin="normal"
              required
              autoComplete="email"
              autoFocus
            />

            <TextField
              fullWidth
              label="Password"
              type="password"
              value={credentials.password}
              onChange={(e) => setCredentials({ ...credentials, password: e.target.value })}
              margin="normal"
              required
              autoComplete="current-password"
            />

            <Button
              type="submit"
              fullWidth
              variant="contained"
              size="large"
              sx={{ mt: 3, mb: 2 }}
              disabled={isLoading}
            >
              {isLoading ? 'Signing In...' : 'Sign In'}
            </Button>

            <Box sx={{ textAlign: 'center' }}>
              <Typography variant="body2">
                Don't have an account?{' '}
                <Link href="/register" underline="hover">
                  Sign Up
                </Link>
              </Typography>
            </Box>
          </form>
        </Paper>
      </Box>
    </Container>
  );
};
```

#### 4.8 Create Register Page

**File:** `frontend/src/pages/Register.tsx`

```typescript
import React, { useState } from 'react';
import {
  Box,
  Container,
  Paper,
  Typography,
  TextField,
  Button,
  Link,
  Alert,
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { RegisterData } from '../types/auth.types';

export const Register: React.FC = () => {
  const navigate = useNavigate();
  const { register } = useAuth();
  const [formData, setFormData] = useState<RegisterData>({
    email: '',
    password: '',
    name: '',
  });
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    // Validate password match
    if (formData.password !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }

    setIsLoading(true);

    try {
      await register(formData);
      navigate('/');
    } catch (err: any) {
      const errorMessage = err.response?.data?.message || 'Registration failed. Please try again.';
      const validationErrors = err.response?.data?.errors;

      if (validationErrors) {
        setError(validationErrors.map((e: any) => e.message).join(', '));
      } else {
        setError(errorMessage);
      }
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Container maxWidth="sm">
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        <Paper elevation={3} sx={{ p: 4, width: '100%' }}>
          <Typography variant="h4" align="center" gutterBottom>
            Budget Tracker
          </Typography>
          <Typography variant="h6" align="center" color="text.secondary" sx={{ mb: 3 }}>
            Create Account
          </Typography>

          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}

          <form onSubmit={handleSubmit}>
            <TextField
              fullWidth
              label="Name"
              value={formData.name}
              onChange={(e) => setFormData({ ...formData, name: e.target.value })}
              margin="normal"
              required
              autoFocus
            />

            <TextField
              fullWidth
              label="Email"
              type="email"
              value={formData.email}
              onChange={(e) => setFormData({ ...formData, email: e.target.value })}
              margin="normal"
              required
              autoComplete="email"
            />

            <TextField
              fullWidth
              label="Password"
              type="password"
              value={formData.password}
              onChange={(e) => setFormData({ ...formData, password: e.target.value })}
              margin="normal"
              required
              autoComplete="new-password"
              helperText="Min 8 characters, 1 uppercase, 1 lowercase, 1 number"
            />

            <TextField
              fullWidth
              label="Confirm Password"
              type="password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              margin="normal"
              required
              autoComplete="new-password"
            />

            <Button
              type="submit"
              fullWidth
              variant="contained"
              size="large"
              sx={{ mt: 3, mb: 2 }}
              disabled={isLoading}
            >
              {isLoading ? 'Creating Account...' : 'Sign Up'}
            </Button>

            <Box sx={{ textAlign: 'center' }}>
              <Typography variant="body2">
                Already have an account?{' '}
                <Link href="/login" underline="hover">
                  Sign In
                </Link>
              </Typography>
            </Box>
          </form>
        </Paper>
      </Box>
    </Container>
  );
};
```

#### 4.9 Update AppBar with Logout

**File:** `frontend/src/components/layout/AppBar.tsx`

Add logout button:

```typescript
import { useAuth } from '../../contexts/AuthContext';
import { Logout as LogoutIcon } from '@mui/icons-material';

export const AppBar = () => {
  const { user, logout } = useAuth();

  // ... existing code ...

  // Add logout button in toolbar
  <IconButton color="inherit" onClick={logout} title="Logout">
    <LogoutIcon />
  </IconButton>

  // Display user name
  <Typography variant="body2" sx={{ mr: 2 }}>
    {user?.name}
  </Typography>
};
```

#### 4.10 Update App.tsx with Auth Provider and Routes

**File:** `frontend/src/App.tsx`

```typescript
import { AuthProvider } from './contexts/AuthContext';
import { ProtectedRoute } from './components/auth/ProtectedRoute';
import { Login } from './pages/Login';
import { Register } from './pages/Register';

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <QueryClientProvider client={queryClient}>
        <AuthProvider>
          <BrowserRouter>
            <Routes>
              {/* Public routes */}
              <Route path="/login" element={<Login />} />
              <Route path="/register" element={<Register />} />

              {/* Protected routes */}
              <Route
                path="/*"
                element={
                  <ProtectedRoute>
                    <Layout>
                      <Routes>
                        <Route path="/" element={<Dashboard />} />
                        <Route path="/accounts" element={<Accounts />} />
                        <Route path="/accounts/:id" element={<AccountDetails />} />
                        <Route path="/transactions" element={<Transactions />} />
                        <Route path="/categories" element={<Categories />} />
                        <Route path="/bank-sync" element={<BankSync />} />
                        <Route path="/development" element={<Development />} />
                      </Routes>
                    </Layout>
                  </ProtectedRoute>
                }
              />
            </Routes>
          </BrowserRouter>
        </AuthProvider>
      </QueryClientProvider>
    </ThemeProvider>
  );
}
```

#### Acceptance Criteria
- ‚úÖ AuthContext provides user state and auth methods
- ‚úÖ Login page with email/password form
- ‚úÖ Register page with name/email/password/confirm
- ‚úÖ ProtectedRoute wrapper redirects to login
- ‚úÖ API client automatically adds Authorization header
- ‚úÖ Auto token refresh on 401 errors
- ‚úÖ Logout clears tokens and redirects
- ‚úÖ User name displayed in AppBar
- ‚úÖ Tokens stored in localStorage
- ‚úÖ Loading spinner during auth initialization

---

### Phase 5: Testing & Validation üß™

**Estimated Time:** 2 hours

#### 5.1 Manual Testing Checklist

**Authentication Flow:**
- [ ] Register new user with valid data
- [ ] Register fails with duplicate email
- [ ] Register fails with weak password
- [ ] Login with correct credentials
- [ ] Login fails with incorrect credentials
- [ ] Token refresh works after 15 minutes
- [ ] Logout clears session and redirects

**Data Isolation:**
- [ ] User A cannot see User B's accounts
- [ ] User A cannot see User B's transactions
- [ ] User A cannot see User B's categories (custom ones)
- [ ] User A cannot see User B's bank connections
- [ ] System categories visible to all users
- [ ] Direct API calls with another user's ID return 404

**Existing Features:**
- [ ] All account operations work (CRUD)
- [ ] All transaction operations work (CRUD)
- [ ] Balance calculations correct
- [ ] CSV import works and associates with correct user
- [ ] Bank sync works and associates with correct user
- [ ] Category management works
- [ ] Dashboard shows only user's data

**Edge Cases:**
- [ ] Expired token handled gracefully
- [ ] Invalid token handled gracefully
- [ ] No token redirects to login
- [ ] Protected routes redirect if not authenticated
- [ ] Token refresh failure redirects to login

#### 5.2 Database Verification Queries

```sql
-- Verify all data has userId
SELECT
  (SELECT COUNT(*) FROM accounts WHERE user_id IS NULL) as accounts_without_user,
  (SELECT COUNT(*) FROM transactions WHERE user_id IS NULL) as transactions_without_user,
  (SELECT COUNT(*) FROM categories WHERE user_id IS NULL AND is_system = false) as user_categories_without_user,
  (SELECT COUNT(*) FROM bank_connections WHERE user_id IS NULL) as connections_without_user;

-- Should all return 0 (except system categories)

-- Verify default user exists and has data
SELECT
  u.email,
  u.name,
  COUNT(DISTINCT a.id) as accounts,
  COUNT(DISTINCT t.id) as transactions
FROM users u
LEFT JOIN accounts a ON a.user_id = u.id
LEFT JOIN transactions t ON t.user_id = u.id
WHERE u.email = 'admin@localhost'
GROUP BY u.id, u.email, u.name;
```

#### 5.3 Security Audit

- [ ] JWT secrets are strong random strings (min 32 chars)
- [ ] Passwords hashed with bcrypt (12 rounds)
- [ ] JWT tokens have proper expiration
- [ ] No sensitive data in JWT payload
- [ ] CORS configured correctly
- [ ] Rate limiting on auth endpoints (TODO: Add in future)
- [ ] SQL injection prevented (Prisma parameterization)
- [ ] XSS prevented (React escaping)
- [ ] No password in logs or error messages

#### Acceptance Criteria
- ‚úÖ All manual test cases pass
- ‚úÖ Database verification queries pass
- ‚úÖ Security audit items checked
- ‚úÖ No regression in existing features
- ‚úÖ Authentication works end-to-end

---

### Phase 6: Documentation Updates üìù

**Estimated Time:** 1 hour

#### 6.1 Update CLAUDE.md

- Update "Current Status" section
- Add authentication to Recent Decisions
- Update Architecture section with auth middleware
- Update Security Considerations with JWT details
- Update Environment Variables with JWT secrets

#### 6.2 Update ROADMAP.md

- Mark Milestone 1.5 as COMPLETE
- Update Milestone 10 (remove auth from it)
- Update Future Enhancements section

#### 6.3 Update README.md

- Add first-time setup instructions (default user credentials)
- Add JWT secret generation instructions
- Update environment variable documentation
- Add authentication flow diagram (optional)

#### 6.4 Create API Documentation

Update Postman collection with:
- Auth endpoints (register, login, refresh, profile)
- Authorization header examples
- Token refresh workflow

#### 6.5 Mark Feature Plan Complete

Update this document with:
- Completion date
- Final commit references
- Implementation notes
- Any deviations from plan

#### Acceptance Criteria
- ‚úÖ All documentation files updated
- ‚úÖ CLAUDE.md reflects new auth architecture
- ‚úÖ ROADMAP.md updated with milestone completion
- ‚úÖ README.md has setup instructions
- ‚úÖ Postman collection includes auth endpoints

---

## Rollback Strategy

If something goes wrong, we can rollback in stages:

### Stage 1: Before Data Migration
- Simply revert the migration: `npx prisma migrate resolve --rolled-back <migration-name>`
- Delete User table
- Remove userId columns

### Stage 2: After Data Migration
- More complex, but still possible
- Revert Prisma schema
- Drop User table
- Remove userId columns (data will remain intact)

### Stage 3: After Full Implementation
- Can disable auth by removing authenticate middleware temporarily
- Can create "bypass" mode for emergency access
- Full rollback requires git revert + database migration

**Best Practice:** Test thoroughly in development before deploying to production.

---

## Security Considerations

### Password Security
- ‚úÖ Bcrypt with 12 rounds (industry standard)
- ‚úÖ Minimum 8 characters
- ‚úÖ Require uppercase, lowercase, number
- ‚úÖ Never log or expose passwords
- ‚ùå Password reset (deferred to future)
- ‚ùå 2FA (deferred to future)

### Token Security
- ‚úÖ JWT with strong secret (min 32 chars)
- ‚úÖ Short access token expiration (15 minutes)
- ‚úÖ Long refresh token expiration (7 days)
- ‚úÖ Token verification on every request
- ‚úÖ Auto token refresh on expiration
- ‚ùå Token rotation (deferred to future)
- ‚ùå Token revocation list (deferred to future)

### Data Security
- ‚úÖ User-level data isolation (userId foreign keys)
- ‚úÖ Query filtering by userId
- ‚úÖ Proper 404 responses (don't leak existence)
- ‚úÖ Cascade deletes configured
- ‚úÖ Prisma prevents SQL injection

### API Security
- ‚úÖ CORS configuration
- ‚úÖ Input validation (Zod)
- ‚úÖ Error handling (no sensitive data)
- ‚ùå Rate limiting on auth endpoints (future)
- ‚ùå Account lockout after failed attempts (future)

---

## Performance Considerations

### Database
- ‚úÖ Indexes on userId columns (added in migration)
- ‚úÖ Efficient query patterns (WHERE userId = ?)
- ‚úÖ Minimal joins (Prisma optimization)

### Token Management
- ‚úÖ JWT stateless (no database lookups)
- ‚úÖ Token caching in memory (localStorage)
- ‚úÖ Automatic refresh prevents re-login

### API Response Times
- Expected: < 50ms overhead for auth middleware
- JWT verification is very fast (~1ms)
- Token refresh adds ~100ms once per 15 minutes

---

## Migration Day Checklist

### Pre-Migration
- [ ] Backup database
- [ ] Test migration in development
- [ ] Generate strong JWT secrets
- [ ] Update .env with JWT secrets
- [ ] Review all code changes
- [ ] Test authentication flow locally

### Migration
- [ ] Run Prisma migration: `npx prisma migrate deploy`
- [ ] Run data backfill script
- [ ] Verify default user created
- [ ] Verify all data has userId
- [ ] Restart backend server
- [ ] Test login with default credentials
- [ ] Test all existing features

### Post-Migration
- [ ] Monitor error logs
- [ ] Test with multiple users
- [ ] Verify data isolation
- [ ] Update Postman collection
- [ ] Update documentation
- [ ] Communicate default credentials to users

---

## Default User Credentials

**IMPORTANT:** After migration, communicate these credentials:

```
Email: admin@localhost
Password: changeme123
```

**Users MUST change password after first login!**

(Consider adding "force password change" in future enhancement)

---

## Future Enhancements (Post-Migration)

- [ ] Password reset flow (email-based)
- [ ] Email verification for registration
- [ ] Two-factor authentication (2FA)
- [ ] OAuth providers (Google, GitHub)
- [ ] Account lockout after failed attempts
- [ ] Rate limiting on auth endpoints
- [ ] Session management (revoke tokens)
- [ ] User roles (admin, user, readonly)
- [ ] Activity logs (audit trail)
- [ ] Password strength meter
- [ ] Remember me functionality
- [ ] Force password change on first login

---

## Success Metrics

- ‚úÖ Zero data loss during migration
- ‚úÖ All existing features work identically
- ‚úÖ Users can register and login
- ‚úÖ Complete data isolation between users
- ‚úÖ Token refresh works automatically
- ‚úÖ No performance degradation
- ‚úÖ Security audit passes
- ‚úÖ Documentation complete

---

## Notes

### Design Decisions

1. **JWT over Sessions**: Stateless, scales better, works well with Docker
2. **15-minute access tokens**: Balance between security and UX
3. **7-day refresh tokens**: Reduce login frequency without sacrificing security
4. **Bcrypt 12 rounds**: OWASP recommendation, good balance of security/performance
5. **Default user pattern**: Preserves existing data, smooth migration
6. **localStorage for tokens**: Simple, works well for SPA, consider httpOnly cookies in future

### Known Limitations

1. No password reset (require manual intervention)
2. No email verification (anyone can register)
3. No rate limiting (vulnerable to brute force)
4. No token revocation (tokens valid until expiry)
5. No 2FA (single factor authentication only)

These are acceptable for initial multi-user support and can be added incrementally.

### Development vs Production

**Development:**
- Default user: admin@localhost / changeme123
- JWT secrets can be weaker (still min 32 chars)
- CORS open to localhost

**Production:**
- Default user credentials should be changed immediately
- JWT secrets MUST be strong random strings (64+ chars recommended)
- CORS restricted to production domain
- HTTPS required
- Consider additional security hardening

---

## Implementation Summary

**To be filled in after completion**

### Commits
- [Commit hash] [Migration] Add User model and userId foreign keys
- [Commit hash] [Feature] Implement authentication service and middleware
- [Commit hash] [Feature] Add auth routes and controllers
- [Commit hash] [Feature] Update all services for user isolation
- [Commit hash] [Feature] Implement frontend authentication
- [Commit hash] [Feature] Add login and register pages
- [Commit hash] [Docs] Update documentation for authentication

### Files Changed
**Backend:** XX files
**Frontend:** XX files
**Database:** XX migrations

### Lines of Code
**Backend:** ~XXX lines
**Frontend:** ~XXX lines
**Total:** ~XXX lines

### Completion Date
**TBD**

---

**Last Updated:** January 13, 2026
**Document Version:** 1.0
**Status:** PLANNED - Ready for implementation
