// Prisma Schema for Budget Tracker

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model - Authentication and user management
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String // bcrypt hashed (12 rounds)
  name      String
  timezone  String   @default("UTC") // IANA timezone (e.g., "Pacific/Auckland", "America/New_York")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  accounts                    Account[]
  transactions                Transaction[]
  categories                  Category[]
  categoryRules               CategoryRule[]
  budgets                     Budget[]
  budgetTemplates             BudgetTemplate[]
  bankConnections             BankConnection[]
  plannedTransactionTemplates PlannedTransactionTemplate[]
  plannedTransactions         PlannedTransaction[]

  @@index([email])
  @@map("users")
}

// Enums for Account and Transaction models
enum AccountType {
  CHECKING
  SAVINGS
  CREDIT_CARD
  CASH
  INVESTMENT
  OTHER
}

enum TransactionType {
  INCOME
  EXPENSE
  TRANSFER
}

enum TransactionStatus {
  PENDING
  CLEARED
  RECONCILED
}

enum BudgetPeriod {
  DAILY
  WEEKLY
  FORTNIGHTLY
  MONTHLY
  ANNUALLY
}

enum BudgetType {
  INCOME
  EXPENSE
}

// Planned Transaction Enums
enum DayOfMonthType {
  FIXED // Use dayOfMonth field (1-31)
  LAST_DAY // Last day of month
  FIRST_WEEKDAY // First Monday-Friday of month
  LAST_WEEKDAY // Last Monday-Friday of month
  FIRST_OF_WEEK // First occurrence of dayOfWeek in month
  LAST_OF_WEEK // Last occurrence of dayOfWeek in month
}

enum ImplicitSpendMode {
  DAILY // Spread evenly across days in period
  END_OF_PERIOD // Assume spent at end of period
  NONE // Don't include in forecast (tracking only)
}

enum MatchMethod {
  AUTO // System auto-matched, high confidence
  AUTO_REVIEWED // System suggested, user confirmed
  MANUAL // User manually linked
}

// Account model - Represents financial accounts (checking, savings, credit cards, etc.)
model Account {
  id             String      @id @default(uuid())
  userId         String
  name           String
  type           AccountType
  category       String? // Custom categorization (e.g., "Personal", "Business")
  currency       String      @default("USD")
  initialBalance Decimal     @db.Decimal(15, 2)
  isActive       Boolean     @default(true)

  // Bank sync fields
  isLinkedToBank Boolean   @default(false)
  lastBankSync   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                              User                         @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions                      Transaction[]                @relation("AccountTransactions")
  transferTransactions              Transaction[]                @relation("TransferDestination")
  linkedAccount                     LinkedAccount? // One-to-one with external account
  plannedTransactionTemplates       PlannedTransactionTemplate[] @relation("PlannedTemplateAccount")
  plannedTransactionTransferTo      PlannedTransactionTemplate[] @relation("PlannedTemplateTransferTo")
  plannedTransactions               PlannedTransaction[]         @relation("PlannedTransactionAccount")
  plannedTransactionTransferToPlans PlannedTransaction[]         @relation("PlannedTransactionTransferTo")

  @@index([userId])
  @@index([isActive])
  @@index([createdAt])
}

// Category model - Represents transaction categories with hierarchical structure
model Category {
  id        String   @id @default(uuid())
  userId    String? // Nullable for system categories
  name      String
  color     String   @default("#757575") // Hex color code
  icon      String? // Optional Material-UI icon name
  parentId  String? // Self-referential for hierarchy
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                        User?                        @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent                      Category?                    @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: Restrict)
  children                    Category[]                   @relation("CategoryHierarchy")
  transactions                Transaction[]
  rules                       CategoryRule[]
  budgets                     Budget[]
  budgetTemplates             BudgetTemplate[]
  plannedTransactionTemplates PlannedTransactionTemplate[]
  plannedTransactions         PlannedTransaction[]

  @@index([userId])
  @@index([parentId])
  @@index([name])
}

// CategoryRule - User-defined rules for automatic categorization
model CategoryRule {
  id         String  @id @default(uuid())
  userId     String? // Nullable for system rules
  name       String // e.g., "Costco â†’ Groceries"
  categoryId String

  // Rule conditions (JSON for flexibility)
  conditions Json

  // Rule metadata
  priority  Int     @default(0) // Higher = evaluated first
  isEnabled Boolean @default(true)
  isSystem  Boolean @default(false)

  // Statistics
  matchCount  Int       @default(0)
  lastMatched DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user     User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Restrict)

  @@index([userId])
  @@index([priority])
  @@index([isEnabled])
  @@map("category_rules")
}

// Budget - Category budgets with period tracking
model Budget {
  id         String @id @default(uuid())
  userId     String
  categoryId String

  // Budget amount
  amount Decimal @db.Decimal(15, 2)

  // Period definition (NULL for one-time budgets)
  periodType BudgetPeriod? // NULL = one-time budget
  interval   Int? // NULL for one-time budgets (e.g., 1 = every period, 2 = every 2 periods)
  startDate  DateTime // When this budget period starts
  endDate    DateTime? // Calculated end date (NULL for one-time budgets)

  // Configuration
  includeSubcategories Boolean           @default(false)
  type                 BudgetType        @default(EXPENSE) // Budget type: income vs expense
  implicitSpendMode    ImplicitSpendMode @default(DAILY) // How to distribute unplanned budget spend in forecasts

  // Metadata
  name  String? // Optional custom name
  notes String?

  // Template linkage
  templateId   String? // Link to template if this is a generated instance
  isCustomized Boolean @default(false) // Track if instance was manually edited

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                        User                         @relation(fields: [userId], references: [id], onDelete: Cascade)
  category                    Category                     @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  template                    BudgetTemplate?              @relation("TemplateBudgets", fields: [templateId], references: [id], onDelete: SetNull)
  plannedTransactionTemplates PlannedTransactionTemplate[]
  plannedTransactions         PlannedTransaction[]

  @@index([userId])
  @@index([categoryId])
  @@index([startDate])
  @@index([templateId])
  @@map("budgets")
}

// BudgetTemplate - Recurring budget templates for automatic budget generation
model BudgetTemplate {
  id         String @id @default(uuid())
  userId     String
  categoryId String

  // Template configuration
  amount               Decimal           @db.Decimal(15, 2)
  periodType           BudgetPeriod
  interval             Int               @default(1) // How often (1 = every period, 2 = every 2 periods)
  includeSubcategories Boolean           @default(false)
  type                 BudgetType        @default(EXPENSE) // Budget type: income vs expense
  implicitSpendMode    ImplicitSpendMode @default(DAILY) // How to distribute unplanned budget spend in forecasts

  // Recurrence settings
  firstStartDate DateTime // When the first budget instance starts
  endDate        DateTime? // Optional end date (null = never ending)

  // Status
  isActive Boolean @default(true)

  // Metadata
  name  String // Template name (required for templates)
  notes String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  budgets  Budget[] @relation("TemplateBudgets")

  @@unique([userId, name])
  @@index([userId])
  @@index([categoryId])
  @@index([isActive])
  @@map("budget_templates")
}

// Transaction model - Represents income, expenses, and transfers
model Transaction {
  id                  String            @id @default(uuid())
  userId              String
  accountId           String
  categoryId          String? // Nullable - links to Category
  type                TransactionType
  amount              Decimal           @db.Decimal(15, 2)
  date                DateTime
  description         String
  merchant            String? // Merchant name from bank
  notes               String?
  status              TransactionStatus @default(CLEARED)
  transferToAccountId String? // Links to destination account for transfers

  // Bank sync field
  isFromBank Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  account             Account              @relation("AccountTransactions", fields: [accountId], references: [id], onDelete: Cascade)
  category            Category?            @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  transferAccount     Account?             @relation("TransferDestination", fields: [transferToAccountId], references: [id], onDelete: SetNull)
  externalTransaction ExternalTransaction? // One-to-one with external transaction
  matchedTransaction  MatchedTransaction? // One-to-one with matched planned transaction

  @@index([userId])
  @@index([accountId])
  @@index([categoryId])
  @@index([date])
  @@index([type])
  @@index([status])
  @@index([transferToAccountId])
}

// ============================================================================
// Bank Synchronization Models
// ============================================================================

// BankConnection - Stores connection to banking provider (Akahu, Plaid, etc.)
model BankConnection {
  id        String    @id @default(uuid())
  userId    String
  provider  String    @default("AKAHU_PERSONAL") // AKAHU_PERSONAL, AKAHU_OAUTH, PLAID, etc.
  status    String    @default("ACTIVE") // ACTIVE, INACTIVE, ERROR
  lastSync  DateTime?
  lastError String?

  // Personal App fields (used now)
  appToken  String? @db.Text // Encrypted, nullable for future OAuth
  userToken String? @db.Text // Encrypted, for Personal App user access token

  // OAuth fields (not used now, ready for future)
  accessToken  String?   @db.Text // Encrypted, null for personal app
  refreshToken String?   @db.Text // Encrypted, null for personal app
  tokenExpiry  DateTime? // null for personal app

  metadata  Json? // Flexible storage for provider-specific data
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  linkedAccounts LinkedAccount[]
  syncHistory    SyncHistory[]

  @@index([userId])
  @@index([provider])
  @@index([status])
}

// LinkedAccount - External account linked to local Account
model LinkedAccount {
  id           String @id @default(uuid())
  connectionId String

  // External provider data
  externalAccountId String // Provider's account ID (e.g., Akahu's _id)
  externalName      String // Account name from provider
  externalType      String // BANK, CARD, etc.
  institution       String // Bank name
  accountNumber     String? // Masked account number

  // Link to local account
  localAccountId String? @unique

  // Sync control
  syncEnabled Boolean   @default(true)
  status      String? // Account status: ACTIVE, CLOSED, DORMANT, ERROR
  lastSync    DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  connection           BankConnection        @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  localAccount         Account?              @relation(fields: [localAccountId], references: [id], onDelete: SetNull)
  externalTransactions ExternalTransaction[]

  @@unique([connectionId, externalAccountId])
  @@index([connectionId])
  @@index([externalAccountId])
  @@index([localAccountId])
  @@index([syncEnabled])
}

// ExternalTransaction - Transaction from banking provider
model ExternalTransaction {
  id              String @id @default(uuid())
  linkedAccountId String

  // External provider data
  externalTransactionId String   @unique // Provider's transaction ID
  date                  DateTime
  amount                Decimal  @db.Decimal(15, 2)
  description           String
  merchant              String?
  category              String? // Provider's category
  type                  String // Provider's type (DEBIT, CREDIT, etc.)
  balance               Decimal? @db.Decimal(15, 2)

  // Link to local transaction
  localTransactionId String? @unique

  // Duplicate detection
  isDuplicate         Boolean @default(false)
  duplicateConfidence Int? // 0-100
  needsReview         Boolean @default(false)

  // Raw data for debugging
  rawData Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  linkedAccount    LinkedAccount @relation(fields: [linkedAccountId], references: [id], onDelete: Cascade)
  localTransaction Transaction?  @relation(fields: [localTransactionId], references: [id], onDelete: SetNull)

  @@index([linkedAccountId])
  @@index([externalTransactionId])
  @@index([localTransactionId])
  @@index([date])
  @@index([isDuplicate])
  @@index([needsReview])
}

// SyncHistory - Track sync job history and status
model SyncHistory {
  id           String @id @default(uuid())
  connectionId String
  type         String // FULL, INCREMENTAL, MANUAL
  status       String // PENDING, IN_PROGRESS, COMPLETED, FAILED

  startedAt   DateTime  @default(now())
  completedAt DateTime?

  // Results
  accountsSynced       Int @default(0)
  transactionsFetched  Int @default(0)
  transactionsImported Int @default(0)
  duplicatesDetected   Int @default(0)
  needsReview          Int @default(0)

  errorMessage String?
  errorDetails Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  connection BankConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@index([connectionId])
  @@index([status])
  @@index([startedAt])
}

// ============================================================================
// Planned Transactions & Forecasting Models
// ============================================================================

// PlannedTransactionTemplate - Defines a recurring pattern for planned transactions
model PlannedTransactionTemplate {
  id     String @id @default(uuid())
  userId String

  // Transaction details
  accountId  String
  categoryId String?

  // For transfers
  isTransfer          Boolean @default(false)
  transferToAccountId String?

  // Amount and type
  amount Decimal         @db.Decimal(12, 2) // Positive for income, negative for expense
  type   TransactionType // INCOME, EXPENSE, TRANSFER

  // Description
  name        String // e.g., "Monthly Rent", "Salary"
  description String? // Optional detailed description
  notes       String?

  // Recurrence pattern
  periodType      BudgetPeriod // DAILY, WEEKLY, FORTNIGHTLY, MONTHLY, ANNUALLY
  interval        Int          @default(1) // Every N periods
  firstOccurrence DateTime // When the pattern starts (stored in UTC)
  endDate         DateTime? // Optional end date (null = indefinite)

  // Day-of-period specification (for flexibility)
  dayOfMonth     Int? // 1-31, null for non-monthly or when using dayOfMonthType
  dayOfMonthType DayOfMonthType? // For floating days (last day, first weekday, etc.)
  dayOfWeek      Int? // 0-6 (Sunday-Saturday), for weekly or "first/last X of month"

  // Matching configuration
  autoMatchEnabled Boolean  @default(true) // Whether to auto-match actual transactions
  skipReview       Boolean  @default(false) // Skip review queue for high-trust items
  matchTolerance   Decimal? @db.Decimal(12, 2) // Amount tolerance for matching (e.g., $5)
  matchWindowDays  Int      @default(7) // Days before/after expected date to match

  // Budget linkage (optional)
  budgetId String?

  // Status
  isActive Boolean @default(true)

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user              User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  account           Account              @relation("PlannedTemplateAccount", fields: [accountId], references: [id], onDelete: Cascade)
  category          Category?            @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  transferToAccount Account?             @relation("PlannedTemplateTransferTo", fields: [transferToAccountId], references: [id], onDelete: SetNull)
  budget            Budget?              @relation(fields: [budgetId], references: [id], onDelete: SetNull)
  overrides         PlannedTransaction[] // Customized instances

  @@index([userId])
  @@index([accountId])
  @@index([categoryId])
  @@index([budgetId])
  @@index([isActive])
  @@index([firstOccurrence])
  @@map("planned_transaction_templates")
}

// PlannedTransaction - Individual planned transaction instance
// Created when user customizes a specific occurrence or creates one-time planned transaction
model PlannedTransaction {
  id     String @id @default(uuid())
  userId String

  // Link to template (null for one-time planned transactions)
  templateId String?

  // Transaction details (can override template values)
  accountId  String
  categoryId String?

  // For transfers
  isTransfer          Boolean @default(false)
  transferToAccountId String?

  // Amount and type
  amount Decimal         @db.Decimal(12, 2)
  type   TransactionType

  // Description
  name        String
  description String?
  notes       String?

  // Timing
  expectedDate DateTime // When this transaction is expected

  // Override flag
  isOverride Boolean @default(false) // True if this overrides a template instance

  // Matching (inherited from template or set directly)
  autoMatchEnabled Boolean  @default(true)
  skipReview       Boolean  @default(false)
  matchTolerance   Decimal? @db.Decimal(12, 2)
  matchWindowDays  Int      @default(7)

  // Budget linkage
  budgetId String?

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user              User                        @relation(fields: [userId], references: [id], onDelete: Cascade)
  template          PlannedTransactionTemplate? @relation(fields: [templateId], references: [id], onDelete: Cascade)
  account           Account                     @relation("PlannedTransactionAccount", fields: [accountId], references: [id], onDelete: Cascade)
  category          Category?                   @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  transferToAccount Account?                    @relation("PlannedTransactionTransferTo", fields: [transferToAccountId], references: [id], onDelete: SetNull)
  budget            Budget?                     @relation(fields: [budgetId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([templateId])
  @@index([accountId])
  @@index([categoryId])
  @@index([budgetId])
  @@index([expectedDate])
  @@index([isOverride])
  @@map("planned_transactions")
}

// MatchedTransaction - Track which actual transactions matched which planned transactions
// Stores match history since we delete the planned transaction after matching
model MatchedTransaction {
  id String @id @default(uuid())

  transactionId String @unique

  // Store the planned transaction details at time of match (since we delete the planned tx)
  plannedTemplateId   String? // Template that generated the planned tx
  plannedExpectedDate DateTime // When it was expected
  plannedAmount       Decimal  @db.Decimal(12, 2)

  // Match metadata
  matchConfidence Decimal     @db.Decimal(5, 2) // 0-100%
  matchedAt       DateTime    @default(now())
  matchMethod     MatchMethod // AUTO, MANUAL, AUTO_REVIEWED

  // Relations
  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@index([transactionId])
  @@index([plannedTemplateId])
  @@index([matchedAt])
  @@map("matched_transactions")
}

// DismissedMatch - Track dismissed match suggestions so they don't reappear
model DismissedMatch {
  id String @id @default(uuid())

  transactionId         String
  plannedTransactionId  String // Can be virtual ID like "virtual_{templateId}_{date}"

  dismissedAt DateTime @default(now())

  @@unique([transactionId, plannedTransactionId])
  @@index([transactionId])
  @@map("dismissed_matches")
}
